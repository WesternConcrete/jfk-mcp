type TextFilter = {
    operator: "contains";
    value: string;
} | {
    operator: "isNull";
};
type KeywordFilter = {
    operator: "eq";
    value: string;
} | {
    operator: "isNull";
};
type DateFilter = {
    operator: "gte" | "lte" | "gt" | "lt" | "eq";
    value: Date;
} | {
    operator: "between";
    value: [Date, Date];
} | {
    operator: "isNull";
};
type NumberFilter = {
    operator: "eq";
    value: number;
} | {
    operator: "gt";
    value: number;
} | {
    operator: "lt";
    value: number;
} | {
    operator: "gte";
    value: number;
} | {
    operator: "lte";
    value: number;
} | {
    operator: "between";
    value: [number, number];
};
interface BaseMetadataFilter {
    link?: KeywordFilter;
    link_id?: KeywordFilter;
    page_id?: KeywordFilter;
}
interface JFKMetadataFilter extends BaseMetadataFilter {
    comments?: TextFilter;
    document_date?: DateFilter;
    document_type?: KeywordFilter;
    file_name?: KeywordFilter;
    file_number?: KeywordFilter;
    formerly_withheld?: KeywordFilter;
    from_name?: KeywordFilter;
    nara_release_date?: DateFilter;
    originator?: KeywordFilter;
    pages_released?: NumberFilter;
    page_count?: NumberFilter;
    record_number?: KeywordFilter;
    review_date?: DateFilter;
    to_name?: KeywordFilter;
}
interface BaseDocumentResult {
    link: string;
    link_id: string;
    page_id: string;
    text: string;
    score?: number;
}
interface JFKDocumentResult extends BaseDocumentResult {
    metadata: {
        comments?: string;
        document_date?: Date;
        document_type?: string;
        file_name?: string;
        file_number?: string;
        formerly_withheld?: string;
        from_name?: string;
        nara_release_date?: Date;
        originator?: string;
        pages_released?: number;
        page_count?: number;
        record_number?: string;
        review_date?: Date;
        to_name?: string;
    };
}
interface TextSearchInput<M = JFKMetadataFilter> {
    query: string;
    metadata?: M;
    limit?: number;
}
interface VectorSearchInput<M = JFKMetadataFilter> {
    query: string;
    metadata?: Omit<M, "comments">;
    limit?: number;
}
interface MetadataSearchInput<M = JFKMetadataFilter> {
    metadata: M;
    limit?: number;
}
interface PageInput {
    page_ids: string[];
}
type PageTextMap = {
    [pageId: string]: {
        text: string;
    };
};
type PagePngMap = {
    [pageId: string]: {
        url: string;
    };
};
type TextSearchPayload<M> = {
    action: "search";
    payload: TextSearchInput<M> & {
        searchType: "text";
    };
};
type VectorSearchPayload<M> = {
    action: "search";
    payload: VectorSearchInput<M> & {
        searchType: "vector";
    };
};
type MetadataSearchPayload<M> = {
    action: "search";
    payload: MetadataSearchInput<M> & {
        searchType: "metadata";
    };
};
type PageTextPayload = {
    action: "pageText";
    payload: PageInput;
};
type PagePngPayload = {
    action: "pagePng";
    payload: PageInput;
};
interface ArchivesApiClientOptions {
    apiKey: string;
}
declare class FileGroupClient<M, D extends JFKDocumentResult> {
    readonly search: {
        text: (input: {
            query: string;
            metadata?: M;
            limit?: number;
        }) => Promise<{
            hits: D[];
            limit: number;
            total: number;
        }>;
        vector: (input: {
            query: string;
            metadata?: M;
            limit?: number;
        }) => Promise<{
            hits: D[];
            limit: number;
        }>;
        metadata: (input: {
            metadata: M;
            limit?: number;
        }) => Promise<{
            hits: D[];
            limit: number;
            total: number;
        }>;
    };
    readonly pages: {
        getText: (input: {
            page_ids: string[];
        }) => Promise<PageTextMap>;
        getPng: (input: {
            page_ids: string[];
        }) => Promise<PagePngMap>;
    };
    private readonly client;
    /**
     *
     * @param apiKey your API key
     * @param fileGroup name of the file group (e.g. "jfk")
     * @param baseUrl optional override for the API endpoint URL
     */
    constructor(apiKey: string, fileGroup: string, baseUrl?: string);
}
declare class ArchivesApiClient {
    readonly jfk: FileGroupClient<JFKMetadataFilter, JFKDocumentResult>;
    /**
     *
     * @param options must include `apiKey`.
     */
    constructor(options: ArchivesApiClientOptions);
}

export { ArchivesApiClient, type BaseDocumentResult, type BaseMetadataFilter, type DateFilter, type JFKDocumentResult, type JFKMetadataFilter, type KeywordFilter, type MetadataSearchInput, type MetadataSearchPayload, type NumberFilter, type PageInput, type PagePngMap, type PagePngPayload, type PageTextMap, type PageTextPayload, type TextFilter, type TextSearchInput, type TextSearchPayload, type VectorSearchInput, type VectorSearchPayload };
