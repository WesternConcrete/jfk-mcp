"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ArchivesApiClient: () => ArchivesApiClient
});
module.exports = __toCommonJS(index_exports);
function transformDateFilter(filter) {
  if (filter.operator === "between") {
    const start = filter.value[0]?.toISOString()?.split("T")?.[0];
    const end = filter.value[1]?.toISOString()?.split("T")?.[0];
    if (!start || !end) {
      throw new Error("Invalid date values for between filter");
    }
    return { operator: filter.operator, value: [start, end] };
  } else if (filter.operator === "isNull") {
    return { operator: filter.operator };
  } else {
    const dateStr = filter.value?.toISOString()?.split("T")?.[0];
    if (!dateStr) throw new Error("Invalid date value for filter");
    return { operator: filter.operator, value: dateStr };
  }
}
var dateFields = ["document_date", "nara_release_date", "review_date"];
function transformMetadata(metadata) {
  if (!metadata) return {};
  const transformed = {};
  const metadataObj = metadata;
  for (const field of dateFields) {
    if (metadataObj[field]) {
      transformed[field] = transformDateFilter(
        metadataObj[field]
      );
    }
  }
  return { ...metadataObj, ...transformed };
}
function transformPayloadDates(payload) {
  if (payload && typeof payload === "object") {
    if ("payload" in payload && payload["payload"] && typeof payload["payload"] === "object") {
      const inner = payload["payload"];
      if ("metadata" in inner && inner.metadata) {
        inner.metadata = transformMetadata(inner.metadata);
      }
    }
  }
  return payload;
}
function transformResponseDates(doc) {
  const newDoc = { ...doc };
  for (const field of dateFields) {
    if (newDoc[field] && typeof newDoc[field] === "string") {
      newDoc[field] = new Date(newDoc[field]);
    }
  }
  return newDoc;
}
var DocumentClient = class {
  apiKey;
  baseUrl;
  fileGroup;
  constructor(apiKey, baseUrl, fileGroup) {
    this.apiKey = apiKey;
    this.baseUrl = baseUrl ?? "http://api.archives-api.com/";
    this.fileGroup = fileGroup;
  }
  async request(payload) {
    let fullPayload = payload;
    if (this.fileGroup) {
      fullPayload = { fileGroup: this.fileGroup, ...payload };
    }
    const transformedPayload = transformPayloadDates(fullPayload);
    const response = await fetch(this.baseUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey
      },
      body: JSON.stringify(transformedPayload)
    });
    if (!response.ok) {
      throw new Error(
        `HTTP error! status: ${response.status} \u2013 ${await response.text()}`
      );
    }
    const json = await response.json();
    return json.data;
  }
  async textSearch(input) {
    const payload = {
      action: "search",
      payload: { ...input, searchType: "text" }
    };
    const results = await this.request(payload);
    return {
      hits: results.hits.map(transformResponseDates),
      limit: results.limit,
      total: results.total
    };
  }
  async vectorSearch(input) {
    if (input.metadata?.comments) {
      throw new Error(
        "Filtering by 'comments' is not supported in vector search. Please remove 'comments'."
      );
    }
    const payload = {
      action: "search",
      payload: { ...input, searchType: "vector" }
    };
    const results = await this.request(payload);
    return {
      hits: results.hits.map(transformResponseDates),
      limit: results.limit
    };
  }
  async metadataSearch(input) {
    const payload = {
      action: "search",
      payload: { ...input, searchType: "metadata" }
    };
    const results = await this.request(payload);
    return {
      hits: results.hits.map(transformResponseDates),
      limit: results.limit,
      total: results.total
    };
  }
  async getPageText(input) {
    const payload = {
      action: "pageText",
      payload: input
    };
    return this.request(payload);
  }
  async getPagePng(input) {
    const payload = {
      action: "pagePng",
      payload: input
    };
    return this.request(payload);
  }
};
var FileGroupClient = class {
  search;
  pages;
  client;
  /**
   *
   * @param apiKey your API key
   * @param fileGroup name of the file group (e.g. "jfk")
   * @param baseUrl optional override for the API endpoint URL
   */
  constructor(apiKey, fileGroup, baseUrl) {
    this.client = new DocumentClient(apiKey, baseUrl, fileGroup);
    this.search = {
      text: this.client.textSearch.bind(this.client),
      vector: this.client.vectorSearch.bind(this.client),
      metadata: this.client.metadataSearch.bind(this.client)
    };
    this.pages = {
      getText: this.client.getPageText.bind(this.client),
      getPng: this.client.getPagePng.bind(this.client)
    };
  }
};
var ArchivesApiClient = class {
  jfk;
  // Future expansions (MLK, RFK, etc.) can follow the same pattern.
  /**
   *
   * @param options must include `apiKey`.
   */
  constructor(options) {
    const { apiKey } = options;
    this.jfk = new FileGroupClient(
      apiKey,
      "jfk"
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ArchivesApiClient
});
